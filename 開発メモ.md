# 開発メモ（運用・デバッグノウハウ）

このリポジトリを触る上での「詰まりやすい点」「調査の観点」「実際に効いた対策」をまとめたメモ。

---

## 1. 推奨の起動方法（ローカル開発）

基本はスクリプト経由で起動する。

### Backend + Worker + DB/Redis

```bash
./start_app.sh
```

- `postgres` / `redis` / `migrate` / `api` / `worker` を起動する。
- Windows/WSL で Docker Desktop が未起動の場合、スクリプト側で **Docker Desktop を起動して待機**する。

### GUI（Next.js）も含めて起動

```bash
./start_app.sh --with-frontend
```

- `frontend` も含めて起動する。
- 起動後に `http://localhost:3000` をブラウザで開く（環境に応じて `powershell.exe` / `cmd.exe` / `xdg-open` / `open` を使用）。

---

## 2. `start_worker.sh` は何をするか

[ start_worker.sh ](start_worker.sh) は「ローカル環境で Celery worker を起動する」ための補助スクリプト。

- `.venv` を有効化（存在すれば）
- `.env` を CRLF 耐性ありで読み込み
- Windows/WSL で Docker Desktop が未起動なら起動・待機
- `backend/` に移動して `celery -A worker worker ...` を起動

注意：
- 通常は `./start_app.sh` が Docker 内で `worker` サービスを起動するので **ローカルの `start_worker.sh` は必須ではない**。
- ただし「ローカルで worker をデバッグしたい」場合に使う。

---

## 3. Windows/WSL で Docker Desktop が未起動なとき

### 症状

- `start_app.sh` 実行時に `Cannot connect to the Docker daemon` 系で失敗。

### 対策

- `start_app.sh` / `start_worker.sh` に以下を実装済み：
  - `docker info` でデーモン疎通確認
  - Windows/WSL のときのみ Docker Desktop を起動（`powershell.exe` 優先、次点で `cmd.exe`）
  - 最大 120 秒待機してダメならエラー

---

## 4. 「文字起こしの終盤が欠落する」問題（重要）

### 現象

- 音声は末尾まで存在するのに、文字起こし結果の末尾が明らかに途中で切れる（文の途中で終了する）。
- 特に「ファイルサイズが 25MB 未満で、1 リクエストで長時間音声を投げている」ケースで起きやすい。

### 原因（このリポジトリでの実際のケース）

- 例：`z1ypv_yHr6k`（約 17 分、約 24.7MB）
  - `chunk_count=1`（分割なし）で `gpt-4o-mini-transcribe` に投げると、末尾が途中で切れる事象を確認。
  - 音声抽出自体は 17:03 あり、音声欠落ではなかった。
  - DB保存/マージで末尾が落ちたのではなく、**単発の transcription 応答が途中で打ち切られている**疑いが濃厚。

### 対策（実装済み）

- `backend/services/audio_preprocessor.py` に `MAX_SINGLE_CHUNK_SEC` を追加。
  - デフォルト `900` 秒（15分）
  - サイズが小さくても、音声が `MAX_SINGLE_CHUNK_SEC` を超える場合は **圧縮→分割→複数チャンクで転写**する。
  - `MAX_SINGLE_CHUNK_SEC <= 0` で無効化可能。

この対策により、同動画が `chunk_count=2` となり、末尾まで文字起こしが入ることを確認。

### 調査手順（切り分け観点）

1) 音声が末尾まで存在するか

```bash
# worker コンテナ内（ffmpeg 同梱）で確認するのが確実
docker compose exec -T worker ffmpeg -i /app/audio_files/<job_id>.m4a 2>&1 | grep -E "Duration:" | head -n 3
```

2) ジョブが「分割されたか」を確認

```bash
docker compose exec -T postgres psql -U postgres -d youtube_transcription \
  -c "select stage, stage_detail from jobs where id='<job_id>';"
```

- `stage_detail` に `{"chunk_count": 1}` なら単発転写。
- `chunk_count > 1` ならチャンク転写。

3) 文字起こしの末尾が途中で切れているか

```bash
docker compose exec -T postgres psql -U postgres -d youtube_transcription \
  -c "select length(text) as len, right(text, 400) as tail from transcripts where job_id='<job_id>' order by created_at desc limit 1;"
```

---

## 5. GUI（フロント）の起動メモ

- Docker 運用なら `docker compose up -d frontend` でも起動できる。
- `./start_app.sh --with-frontend` が一番手間が少ない。

ログ：

```bash
docker compose logs -f frontend
```

---

## 6. エクスポート仕様（重要）

エクスポートは backend の API が最終決定する（フロントのタブ表示とは独立）。

### エクスポート対象テキスト（TXT/SRT/VTT 共通）

- **校正後が存在する場合**：`corrected_transcripts.corrected_text` をエクスポート
- **校正後が無い場合**：`transcripts.text`（オリジナル）をエクスポート

つまり「校正を一度でも実行して DB に保存されている」ジョブは、エクスポートが校正後に切り替わる。

### タイムスタンプ（SRT/VTT）

- `segments` は **常にオリジナル transcript 側**（`transcripts.segments_json`）から読み込む。
- そのため、SRT/VTT は「校正後テキスト」を出しつつ「オリジナルの segments」を使う構成になり得る。
  - 仕様上そうなっているので、もし校正後に合わせた厳密なタイムスタンプが必要なら別設計が必要。

### エンドポイント

```text
GET /api/jobs/{job_id}/export?format=txt|srt|vtt
```

---

## 7. 開発用の環境変数（抜粋）

- `OPENAI_API_KEY`：必須
- `MAX_UPLOAD_MB` / `TARGET_UPLOAD_MB` / `AUDIO_BITRATE_KBPS` / `CHUNK_OVERLAP_SEC`：大容量・分割関連
- `MAX_SINGLE_CHUNK_SEC`：長時間単発転写の末尾欠落を避けるガード（デフォルト 900）

---

## 8. 既知の注意点

- `pytest` がホスト側に入っていない環境がある（`requirements.txt` には入っている）。
  - venv を使うか、コンテナ内で実行する。
- `frontend` は Docker で起動する構成のため、Node.js をホストに入れなくても動かせる（ローカルで `npm run dev` したい場合は別）。
